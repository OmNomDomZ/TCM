
simplifyByIdentity
Упрощает выражение на основе заданных тождеств.
Основной алгоритм:
Проверяет, существует ли идентичное выражение в дереве тождеств (identityTree).
Заменяет выражение на его эквивалент из дерева.


// структура, которая задает тождество
identity(from: AlgExp, to: AlgExp);
Она связывает выражение from с его упрощённым эквивалентом to. Например:


# matchIdentity
1. Входные параметры:
    * exprr: выражение, которое нужно упростить.
    * identityTree: дерево тождеств, где:  
    Ключи — выражения-шаблоны (AlgExp).
 
      Значения — упрощённые выражения, соответствующие этим шаблонам.

2. Рекурсивный алгоритм:
    * Функция сначала разбивает выражение на подвыражения (левую и правую части для суммы, разности и т.д.).
    * Вызывает себя для каждой части подвыражения.
    * После обхода подвыражений проверяет, совпадает ли результат с каким-либо тождеством.


# matchTemplate
Эта функция сопоставляет шаблон тождества с выражением.
Она проверяет, можно ли выразить выражение через шаблон, подставляя конкретные переменные.

Если шаблон — это переменная, она связывается с соответствующим подвыражением.
Если шаблон — операция (например, сумма или умножение), проверяются структуры обоих выражений:
Левый и правый операнды шаблона сопоставляются с левым и правым операндами выражения.


# simplifyByIdentity
Функция simplifyByIdentity предназначена для проверки, можно ли текущему выражению expr сопоставить упрощённое представление, находящееся в дереве тождеств identityTree.

## Как работает
1. Функция ищет, есть ли выражение expr в дереве identityTree как ключ.
2. Если выражение найдено, оно заменяется на значение, ассоциированное с этим ключом.
3. Если выражение не найдено, оно остаётся без изменений.

# resolveVars
Функция resolveVars заменяет переменные в выражении (AlgExp) их значениями из заданного дерева подстановок varResolve.
## Как работает
1. Если текущий узел выражения — это число (AlgRat) или переменная (AlgVar):
    * Для чисел ничего не изменяется.
    * Для переменных ищем их значение в дереве подстановок varResolve. Если значение найдено, заменяем переменную на это значение.
2. Если текущий узел — это операция (например, сумма, разность, умножение), рекурсивно вызываем resolveVars для всех её аргументов.
3. Унарный минус (AlgNeg) обрабатывается отдельно, также рекурсивно.